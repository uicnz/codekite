---
title: Build a Docstring Search Engine
---

In this tutorial you'll build a semantic search tool on top of `codekite`
using **docstring-based indexing**.

Why docstrings?  Summaries distill *intent* rather than syntax.  Embedding these
short natural-language strings lets the vector DB focus on meaning, giving you
relevant hits even when the literal code differs (e.g., `retry()` vs
`attempt_again()`).  It also keeps the index small (one embedding per file or
symbol instead of dozens of raw-code chunks).

---

## 1. Install dependencies

```sh
uv pip install codekite[openai] sentence-transformers chromadb
```

## 2. Initialise a repo and summarizer

```python
import codekite
from sentence_transformers import SentenceTransformer

REPO_PATH = "/path/to/your/project"
repo = codekite.Repository(REPO_PATH)

summarizer = repo.get_summarizer()  # defaults to OpenAIConfig
```

## 3. Build the docstring index

```python
embed_model = SentenceTransformer("all-MiniLM-L6-v2")
embed_fn = lambda txt: embed_model.encode(txt).tolist()

indexer = codekite.DocstringIndexer(repo, summarizer, embed_fn)
indexer.build()          # writes .codekite/docstring_db
```

The first run will take time depending on repo size and LLM latency.
Summaries are cached inside the vector DB, so subsequent runs are cheap.

## 4. Query the index

```python
searcher = codekite.SummarySearcher(indexer)

results = searcher.search("How is the retry back-off implemented?", top_k=3)
for hit in results:
    print("â†’", hit["file"], "\n", hit["summary"])
```

You now have a semantic code searcher, using powerful docstring summaries,
as easy as that.
